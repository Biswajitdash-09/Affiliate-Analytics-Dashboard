import { NextResponse } from 'next/server'
import { getDb, withRetry } from '@/lib/db'
import { EVENTS_COLLECTION } from '@/models/ShortLink'
import { USERS_COLLECTION } from '@/models/User'
import { AFFILIATE_PROFILES_COLLECTION } from '@/models/AffiliateProfile'
import { REVENUE_COLLECTION } from '@/models/Revenue'

/**
 * GET /api/analytics/cohort
 * Retrieves cohort analysis data
 * Query Parameters:
 * - cohortBy: 'signup_date' | 'revenue_range' | 'activity_level'
 * - startDate: ISO date string
 * - endDate: ISO date string
 * - period: 'weekly' | 'monthly' (default: monthly)
 */
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url)
    const cohortBy = searchParams.get('cohortBy') || 'signup_date'
    const period = searchParams.get('period') || 'monthly'
    
    const startDate = searchParams.get('startDate') 
      ? new Date(searchParams.get('startDate'))
      : new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // 90 days default
    
    startDate.setHours(0, 0, 0, 0)
    
    const endDate = searchParams.get('endDate')
      ? new Date(searchParams.get('endDate'))
      : new Date()
    endDate.setHours(23, 59, 59, 999)

    const db = await getDb()
    
    // Build aggregation pipeline based on cohort type
    const cohortData = await withRetry(async () => {
      if (cohortBy === 'signup_date') {
        return await calculateSignupDateCohorts(db, startDate, endDate, period)
      } else if (cohortBy === 'revenue_range') {
        return await calculateRevenueRangeCohorts(db, startDate, endDate, period)
      } else if (cohortBy === 'activity_level') {
        return await calculateActivityLevelCohorts(db, startDate, endDate, period)
      } else {
        throw new Error(`Invalid cohort type: ${cohortBy}`)
      }
    })

    return NextResponse.json({
      success: true,
      data: {
        cohortBy,
        period,
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        cohorts: cohortData
      }
    })

  } catch (error) {
    console.error('Cohort analysis error:', error)
    return NextResponse.json(
      { success: false, error: 'Failed to retrieve cohort data' },
      { status: 500 }
    )
  }
}

/**
 * Calculate cohorts by signup date
 * Tracks users who signed up in each time period
 */
async function calculateSignupDateCohorts(db, startDate, endDate, period) {
  const usersCollection = db.collection(USERS_COLLECTION)
  const profilesCollection = db.collection(AFFILIATE_PROFILES_COLLECTION)
  const revenueCollection = db.collection(REVENUE_COLLECTION)

  const periodFormat = period === 'weekly' ? '%Y-%U' : '%Y-%m'
  const cohortLabels = generateCohortLabels(startDate, endDate, period)

  // Build aggregation pipeline
  const pipeline = [
    {
      $match: {
        createdAt: {
          $gte: startDate.toISOString(),
          $lte: endDate.toISOString()
        },
        role: 'affiliate'
      }
    },
    {
      $lookup: {
        from: AFFILIATE_PROFILES_COLLECTION,
        localField: '_id',
        foreignField: 'userId',
        as: 'profileData'
      }
    },
    {
      $group: {
        _id: {
          $dateToString: {
            format: periodFormat,
            date: { $toDate: '$createdAt' }
          }
        },
        affiliateIds: { $push: '$_id' },
        count: { $sum: 1 }
      }
    },
    {
      $sort: { _id: 1 }
    }
  ]

  const cohorts = await db.collection(USERS_COLLECTION).aggregate(pipeline).toArray()

  // For each cohort, calculate retention and revenue over time
  const enhancedCohorts = await Promise.all(cohorts.map(async (cohort) => {
    const affiliateIds = cohort.affiliateIds
    
    // Calculate revenue generated by this cohort
    const revenueResult = await revenueCollection.aggregate([
      {
        $match: {
          affiliateId: { $in: affiliateIds },
          status: 'succeeded',
          createdAt: { $gte: startDate.toISOString(), $lte: endDate.toISOString() }
        }
      },
      {
        $group: {
          _id: null,
          totalRevenue: { $sum: '$amount' },
          totalConversions: { $sum: 1 },
          avgRevenue: { $avg: '$amount' }
        }
      }
    ]).toArray()

    const stats = revenueResult[0] || { totalRevenue: 0, totalConversions: 0, avgRevenue: 0 }

    return {
      cohortLabel: cohort._id,
      affiliateCount: cohort.count,
      affiliateIds: cohort.affiliateIds,
      totalRevenue: stats.totalRevenue,
      totalConversions: stats.totalConversions,
      avgRevenuePerUser: cohort.count > 0 ? stats.totalRevenue / cohort.count : 0,
      conversionRate: cohort.count > 0 ? (stats.totalConversions / cohort.count) * 100 : 0,
      retentionData: await calculateRetention(db, affiliateIds, startDate, endDate, period)
    }
  }))

  return enhancedCohorts
}

/**
 * Calculate cohorts by revenue range
 * Groups affiliates by their total revenue
 */
async function calculateRevenueRangeCohorts(db, startDate, endDate, period) {
  const profilesCollection = db.collection(AFFILIATE_PROFILES_COLLECTION)

  const ranges = [
    { name: '$0 - $1,000', min: 0, max: 1000 },
    { name: '$1,000 - $5,000', min: 1000, max: 5000 },
    { name: '$5,000 - $10,000', min: 5000, max: 10000 },
    { name: '$10,000 - $25,000', min: 10000, max: 25000 },
    { name: '$25,000+', min: 25000, max: Infinity }
  ]

  const cohortResults = await Promise.all(ranges.map(async (range) => {
    const result = await profilesCollection.aggregate([
      {
        $match: {
          total_earnings: { 
            $gte: range.min,
            ...(range.max !== Infinity ? { $lt: range.max } : {})
          }
        }
      },
      {
        $group: {
          _id: null,
          count: { $sum: 1 },
          totalRevenue: { $sum: '$total_earnings' },
          avgRevenue: { $avg: '$total_earnings' }
        }
      }
    ]).toArray()

    return {
      cohortLabel: range.name,
      affiliateCount: result[0]?.count || 0,
      totalRevenue: result[0]?.totalRevenue || 0,
      avgRevenue: result[0]?.avgRevenue || 0
    }
  }))

  return cohortResults
}

/**
 * Calculate cohorts by activity level
 * Groups affiliates by click volume or conversion rate
 */
async function calculateActivityLevelCohorts(db, startDate, endDate, period) {
  const profilesCollection = db.collection(AFFILIATE_PROFILES_COLLECTION)
  const clickEventsCollection = db.collection('click_events')
  const revenueCollection = db.collection(REVENUE_COLLECTION)

  const levels = [
    { name: 'High Performers', minClicks: 1000 },
    { name: 'Moderate Activity', minClicks: 100, maxClicks: 999 },
    { name: 'Low Activity', minClicks: 0, maxClicks: 99 },
    { name: 'Inactive', minClicks: 0, maxClicks: 0 }
  ]

  const cohortResults = await Promise.all(levels.map(async (level) => {
    const match = {
      total_clicks: { $gte: level.min }
    }
    if (level.maxClicks !== undefined) {
      match.total_clicks.$lte = level.maxClicks
    }

    const profiles = await profilesCollection.find(match).toArray()
    const affiliateIds = profiles.map(p => p.userId)

    if (affiliateIds.length === 0) {
      return {
        cohortLabel: level.name,
        affiliateCount: 0,
        totalRevenue: 0,
        avgRevenue: 0
      }
    }

    const revenueResult = await revenueCollection.aggregate([
      {
        $match: {
          affiliateId: { $in: affiliateIds },
          createdAt: { $gte: startDate.toISOString(), $lte: endDate.toISOString() }
        }
      },
      {
        $group: {
          _id: null,
          totalRevenue: { $sum: '$amount' },
          avgRevenue: { $avg: '$amount' },
          count: { $sum: 1 }
        }
      }
    ]).toArray()

    return {
      cohortLabel: level.name,
      affiliateCount: affiliateIds.length,
      totalRevenue: revenueResult[0]?.totalRevenue || 0,
      avgRevenue: affiliateIds.length > 0 
        ? (revenueResult[0]?.totalRevenue || 0) / affiliateIds.length 
        : 0
    }
  }))

  return cohortResults
}

/**
 * Calculate retention for a cohort
 * Returns metrics for each period after signup
 */
async function calculateRetention(db, affiliateIds, startDate, endDate, period) {
  const revenueCollection = db.collection(REVENUE_COLLECTION)
  const profilesCollection = db.collection(AFFILIATE_PROFILES_COLLECTION)
  const clickEventsCollection = db.collection('click_events')

  // Calculate revenue per affiliate for each period
  const retentionPeriods = []
  
  // Group by month/week since first activity
  const periodFormat = period === 'weekly' ? '%Y-%U' : '%Y-%m'
  
  const revenueByPeriod = await revenueCollection.aggregate([
    {
      $match: {
        affiliateId: { $in: affiliateIds },
        createdAt: { $gte: startDate.toISOString(), $lte: endDate.toISOString() },
        status: 'succeeded'
      }
    },
    {
      $group: {
        _id: {
          affiliateId: '$affiliateId',
          period: {
            $dateToString: {
              format: periodFormat,
              date: { $toDate: '$createdAt' }
            }
          }
        },
       Revenue: { $sum: '$amount' },
        conversions: { $sum: 1 }
      }
    },
    {
      $sort: { '_id.period': 1 }
    }
  ]).toArray()

  if (revenueByPeriod.length > 0) {
    retentionPeriods.push({
      'Period 1': {
        affiliateCount: affiliateIds.length,
        revenue: revenueByPeriod.reduce((sum, item) => sum + item.Revenue, 0),
        conversions: revenueByPeriod.reduce((sum, item) => sum + item.conversions, 0)
      }
    })
  }

  return retentionPeriods
}

/**
 * Generate cohort labels for date range
 */
function generateCohortLabels(startDate, endDate, period) {
  const labels = []
  const current = new Date(startDate)
  
  while (current <= endDate) {
    const label = period === 'weekly'
      ? `Week of ${current.toLocaleDateString()}`
      : `${current.toLocaleString('default', { month: 'long', year: 'numeric' })}`
    
    labels.push(label)
    
    // Advance to next period
    if (period === 'weekly') {
      current.setDate(current.getDate() + 7)
    } else {
      current.setMonth(current.getMonth() + 1)
    }
  }
  
  return labels
}